算法：
	*计算=信息处理
		借助某种工具，遵照一定规则，以明确而机械的形式进行
	*计算模型=计算机=信息处理工具
	*所谓算法，即特定计算模型下，皆在解决特定问的指令序列
		输入	待处理的信息（问题）
		输出	经处理的信息（答案）
		正确性	的确可以解决指定的问题
		确定行	任何一算法都可以秒杀为一个由基本操作组成的序列
		可行性	每一基本操作都可实现，且在常数时间内完成
		有穷性	对于任何输入，经有穷次基本操作，都可以得到输出
			hailstone 冰雹序列
			hailstone(n):     {1}                 n<=1
						 {n} U hailstone(n/2)     n偶数
						 {n} U hailstone(3n+1)    n奇数
			hailstone(42)={42,21,64,32,....,1}
	Ta(n):用算法A求解某一问题规模为n的实例，所需的计算成本讨论特定算法A（以及对应的问题）时，简记做T(n)
		=max{T(p)| |p|=n}
		最坏的情况。
	好算法：
		*正确：符合语法，能够编译、链接
			   能够正确处理简单的输入
			   能够正确处理大规模的输入
			   能够正确处理一般性的输入
			   能够正确处理退化的输入
			   能够正确处理任意合法的输入
		*健壮：能分辨出不合法的输入并做适当的处理，而不至于非正常退出
		*可读：结构化+准确命名+注释+....
		*效率：速度尽可能的快；存储空间尽可能的少；
计算模型：
		Data Structure +Algorithm     DSA
		空间复杂度S(n)：占用存储空间的大小
		时间复杂度T(n)：耗费时间的长度
算法分析：
		一、正确性：算法功能与问题要求一致
		二、成本：运行时间+所需存储空间
		Ta(P)=算法A求解问题实例P的计算成本
		问题实例的规模，往往是决定计算成本的主要因素
		通常：规模接近，计算成本也接近
		      规模扩大，计算成本亦上升
		算法效率考虑最坏的情况 max(xxx)
图灵机模型：Turing Machine
		tape 依次均匀地换分为单元格
			 各注有某一字符，默认为 '#' cell
		alphabet 字符的类型有限
		head	总是对准某一单元格，并可读取和改写其中的字符
				每经过一个节拍，可专向左侧或右侧的邻格  （读写头）
		state   TM总是处于有限中状态中的某一种
				每经过一个节拍，可（按照规则）转向另一种状态
		Transition Function：(q,c;d,L/R,p)
							q:图灵机读写头当前所处的状态
							c：读写头所针对的单元里的所存的字符
							d：填入的或者修改后的字符
							L/R:修改完成之后，读写头可以向左或者向右移动一个格
							p：当前状态更改为p；q--->p
							demo:(<,1,0,L,<)
random access machine:
		寄存器顺序编号，总数没有限制
			R[0],R[1],R[2],R[3],R[4],R[5].....
		每一基本操作仅需常数时间
		与TM模型一样，RAM模型也是一般计算工具的简化与抽象
		使我们可以独立于具体的平台，对算法的效率做出可信的比较与评判
		在这些模型中：
			算法的运行时间 约等于 算法需要执行的基本操作次数
			T(n)=算法为求解规模为n的问题，所需执行的基本操作次数
	floor,向下取整（********）

大O记号：
		好读书不求甚解
		

迭代与递归：
	凡治众如只寡，分数是也
	
	数组求和：
		迭代：
			int sum(int A[],int n){
				int sum=0;
				for(int i=0;i<n;i++)
					sum+=A[i];		
				return sum;		
			}
			复杂度：O(n)
		
		线性递归：
			sum(int A[],int n){
				return (n<1)?0:sum(A,n-1)+A[n-1];  
			}
			复杂的：O(n)
		递推方程：T(n)=T(n-1)+O(1)

	减而治之
	分而治之

		
动态规划：
		通过递归找出算法的本质，并且给出一个初步的解之后，再将其等效地转化为迭代的形式
		消除重复计算，提高效率
		LCS

接口与实现

sequence{verctor，list}

抽象数据类型=数据模板+定义在改模型上的一组操作

数据结构=基于某种特定语言，实现ADT的一整套算法

向量：
寻秩访问
静态空间管理
上溢 向量不足以存放所有的yuans

下溢 空间的利用率小于50%(装填因子)

向量：

	递增策略 Θ(n),
	倍增策略 Θ(1) 空间换效率

分摊复杂度


无序向量：
	比对操作


有序向量：
	比较操作
有序/无序序列中，任意/总有一对相邻元素顺序/逆序
因此，相邻逆序对的数目，可用一度量向量的逆序程度
删除重复变量
低效：循环，一个一个remove
高效：移动位置，跳过雷同这，发现不通的元素时，闲钱移至紧邻于前者右侧